---
description: Agent execution workflow constraints and behavioral guidelines for working with this codebase
alwaysApply: true
---
# Agent Execution Workflow

Act as a thoughtful planning assistant that respects user control over execution and approval workflows.

## Task File Lifecycle

Task files follow a strict three-phase lifecycle with different access permissions:

```
PLANNING PHASE (writable):
  - Task file is WRITABLE
  - Create/modify markdown requirements and approach
  - Document success criteria and dependencies
  - Status: üìã PLANNED

EXECUTION PHASE (READ-ONLY):
  - Task file is READ-ONLY
  - Read task for guidance only
  - Make ALL changes in source files
  - DO NOT modify task file contents
  - After implementation, update status to: ‚è∏Ô∏è PENDING REVIEW
  
COMPLETION PHASE (status only):
  - User verifies implementation
  - User approves ‚Üí Agent updates status to: ‚úÖ COMPLETED
  - Only status marker changes, no other modifications
```

**CRITICAL**: During execution, task files are read-only references. All implementation work happens in source files.

## Core Workflow Principles

### 1. Terminal Command Constraints

**CRITICAL**: Agents must NEVER run servers or persistent commands in terminals.

```
FORBIDDEN:
  npm run dev
  npm start
  yarn dev
  next dev
  any long-running process
  any background daemon
  any watch mode command

REASON:
  Leave terminal control to the user
  Prevents resource conflicts
  User manages their own development environment
```

### 2. Task Approval Protocol

**CRITICAL**: Tasks must NOT be marked as complete until user explicitly approves after execution review.

```
WORKFLOW:
  1. Plan task ‚Üí Present for approval ‚Üí Status: üìã PLANNED
  2. Execute task (in source files) ‚Üí Status: ‚è∏Ô∏è PENDING REVIEW
  3. User reviews execution results
  4. User explicitly approves ‚Üí Status: ‚úÖ COMPLETED

NEVER:
  - Auto-mark tasks complete after execution
  - Assume approval from silence
  - Skip PENDING REVIEW status
  - Mark complete before user verifies
```

### 3. Task File Purpose

**CRITICAL**: Task files are planning documents, NOT execution logs.

```
TASK FILES SHOULD:
  ‚úì Lay out the path for resolution
  ‚úì Document requirements and approach
  ‚úì Provide markdown notes and guidance
  ‚úì Define success criteria
  ‚úì List dependencies and context

TASK FILES SHOULD NOT:
  ‚úó Contain code implementations
  ‚úó Resolve issues directly
  ‚úó Include file contents or diffs
  ‚úó Be execution logs

PATTERN:
  Tasks are maps, not the journey itself
  Code changes happen in source files
  Task files guide the work
```

## Integration with Task Creator

When using @task-creator.mdc workflow:

```typescript
createTask() {
  1. Gather context
  2. Create markdown task file with:
     - Clear goal statement
     - Requirements (Given X, should Y format)
     - Implementation notes/guidance
     - Success criteria
  3. Present plan for approval
  4. DO NOT include code implementations in task file
}

executeTask() {
  1. Reference task file for guidance (READ-ONLY)
  2. Make code changes in source files (NOT in task file)
  3. Update task status to: ‚è∏Ô∏è PENDING REVIEW
  4. Report completion with summary
  5. WAIT for explicit user verification
  6. After user approves, update status to: ‚úÖ COMPLETED
}
```

## Interaction Patterns

### Planning Phase
```markdown
Agent: "I'll create a task file that outlines..."
Agent: *creates task with markdown notes and requirements*
Agent: "Ready to proceed? [awaiting approval]"
```

### Execution Phase
```markdown
Agent: "Executing based on task guidance..."
Agent: *reads task file (READ-ONLY)*
Agent: *makes changes to source files (NOT task file)*
Agent: *updates task status to ‚è∏Ô∏è PENDING REVIEW*
Agent: "Implementation complete. Please review."
Agent: [WAITS for verification]
```

### Approval Phase
```markdown
User: "Looks good" | "Approved" | "Ship it"
Agent: *updates task status to ‚úÖ COMPLETED*
Agent: "Task marked complete."
```

## Status Markers

```markdown
Task Status Lifecycle:
üìã PLANNED        ‚Üí Task created with requirements (planning phase complete)
üöß IN PROGRESS    ‚Üí Execution approved and underway
‚è∏Ô∏è PENDING REVIEW ‚Üí Implementation complete, awaiting user verification
‚úÖ COMPLETED      ‚Üí User verified and approved
üö´ CANCELLED      ‚Üí Task abandoned

Critical Flow:
  üìã PLANNED ‚Üí üöß IN PROGRESS ‚Üí ‚è∏Ô∏è PENDING REVIEW ‚Üí ‚úÖ COMPLETED
                                      ‚Üë
                                 WAIT HERE for user verification
```

## Anti-Patterns to Avoid

```typescript
// ‚ùå DON'T: Run dev server
await shell("npm run dev")

// ‚ùå DON'T: Auto-complete task
task.status = "completed" // without user approval

// ‚ùå DON'T: Put code in task file
"""
## Implementation
```javascript
export function myCode() { ... }
"""

// ‚úÖ DO: Guide without executing persistent commands
"""
## To verify locally
User should run: `npm run dev`
Then navigate to: http://localhost:3000
"""

// ‚úÖ DO: Set pending review status and wait
"""
**Status**: ‚è∏Ô∏è PENDING REVIEW

Implementation completed. Awaiting user verification before marking complete.
"""

// ‚úÖ DO: Keep tasks as guidance
"""
## Implementation Approach
- Create file at lib/utils/helper.ts
- Export pure function with signature...
- Add unit tests in helper.test.ts
"""
```

## Commands Reference

When working within this workflow:

```bash
/task    # Create task file (markdown planning document)
/execute # Execute based on task guidance (code in source files)
/list    # Show task status (respect approval gates)
```

## Summary

Three cardinal rules:
1. **No persistent terminal commands** - Let user control their environment
2. **Task files are read-only during execution** - Plans in markdown, code in source files
3. **Three-phase workflow** - Plan ‚Üí Execute (‚è∏Ô∏è PENDING REVIEW) ‚Üí User Verifies ‚Üí Complete (‚úÖ)
